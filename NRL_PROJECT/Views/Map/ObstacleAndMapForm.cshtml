@model NRL_PROJECT.Models.ObstacleData

@section Styles {
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/@@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css" />
}

<div class="text-center mb-10">
	<h1 class="text-4xl md:text-5xl font-extrabold text-sky-400 tracking-tight"> Registrer hinder</h1>
	<p class="text-slate-300 mt-3 text-lg">Fyll inn rapportdetaljer, legg til et bilde og marker posisjon p√• kartet.</p>
</div>

<!--  Melding om at du jobber med utkast -->
<div id="restoreNotice"
     class="bg-yellow-600/70 text-white text-center p-4 rounded-xl mb-6 font-semibold shadow-md"
     style="display:none;">
    ‚ö†Ô∏è Et tidligere utkast ble gjenopprettet. Du kan fortsette der du slapp.
    <button id="clearDraftBtn"
            type="button"
            class="ml-3 bg-red-700 hover:bg-red-800 text-white px-3 py-1 rounded-lg font-semibold shadow-md">
        T√∏m utkast
    </button>
</div>

<form asp-action="SubmitObstacleWithLocation" asp-controller="Map" method="post" enctype="multipart/form-data" class="space-y-10">
	@Html.AntiForgeryToken()

    <script>
        // Nullstill utkast hvis brukeren kommer fra en annen side
        if (performance.navigation.type !== performance.navigation.TYPE_RELOAD) {
            localStorage.removeItem("ObstacleReportForm");
        }
    </script>


	<!--  OBSTACLE INFORMATION -->
	<div class="bg-slate-700/60 rounded-2xl p-8 shadow-lg border border-slate-600">
        <h2 class="text-2xl font-bold text-sky-300 mb-6"> Informasjon om hinderet</h2>
        
        <!--  MAP SECTION -->
        <div class="bg-slate-700/60 rounded-2xl p-8 shadow-lg border border-slate-600">
            <h2 class="text-2xl md:text-3xl font-bold text-amber-400 mb-4 text-center">üó∫Ô∏è Marker hinder i kartet</h2>
            <p class="text-center text-slate-300 mb-8 text-lg">Bruk kartverkt√∏yene for √• markere hinderet.</p>

            <div id="mapDraw" class="z-10" style="height: 400px;"></div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
			<div>
				<label asp-for="ObstacleComment" class="block text-sm font-medium text-sky-200">Kommentar</label>
				<textarea asp-for="ObstacleComment" rows="3" class="mt-1 block w-full bg-slate-900 border-slate-600 text-white rounded-lg px-3 py-2 focus:ring-2 focus:ring-sky-400 focus:outline-none"></textarea>
				<span asp-validation-for="ObstacleComment" class="text-red-500 text-sm"></span>
			</div>

			<div>
				<label asp-for="ImageFile" class="block text-sm font-medium text-sky-200">Last opp bilde</label>
				<input asp-for="ImageFile"
					   type="file"
					   accept="image/*"
					   capture="environment"
					   class="mt-1 block w-full bg-slate-900 border-slate-600 text-white rounded-lg px-3 py-2 focus:ring-2 focus:ring-sky-400 focus:outline-none" />
				<span asp-validation-for="ImageFile" class="text-red-500 text-sm"></span>
			</div>

		</div>

		<!-- Hidden map fields -->
        <input type="hidden" asp-for="MapData.GeoJsonCoordinates" id="GeoJsonCoordinates" />

	</div>
    
	<!--  SUBMIT / CANCEL BUTTONS -->
	<div class="flex flex-col md:flex-row justify-center gap-6 mt-10">
		<button type="submit"
				class="bg-emerald-600 hover:bg-emerald-700 text-white px-10 py-4 rounded-2xl font-bold text-xl shadow-lg hover:shadow-2xl transform hover:-translate-y-1 transition-all">
			 Submit Report
		</button>
		<a asp-action="Index" asp-controller="Home"
		   class="bg-red-600 hover:bg-red-700 text-white px-10 py-4 rounded-2xl font-bold text-xl shadow-lg hover:shadow-2xl transform hover:-translate-y-1 transition-all text-center">
			 Cancel
		</a>
	</div>
</form>


@if (!ViewData.ModelState.IsValid)
{
	<div class="bg-red-600 text-white p-4 rounded-lg mb-6">
		<ul class="list-disc list-inside">
			@foreach (var error in ViewData.ModelState.Values.SelectMany(v => v.Errors))
			{
				<li>@error.ErrorMessage</li>
			}
		</ul>
	</div>
}

@section Scripts {
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js"></script>
    <script>
        // Init kartet med fallback til et standardpunkt
        const map = L.map('mapDraw', {zoomControl: false }).setView([58.333, 8.233], 13);

        L.tileLayer.wms('https://wms.geonorge.no/skwms1/wms.topo', {
            layers: 'topo',
            format: 'image/png',
            transparent: false,
            attribution: '¬© Kartverket'
        }).addTo(map);

        // Zoom control (already created at bottom-right)
        const zoomCtl = L.control.zoom({ position: 'bottomright' }).addTo(map);

        map.pm.addControls({
            position: 'bottomright',
            drawText: false,
            drawMarker: true,
            drawPolyline: true,
            drawPolygon: false,
            drawCircle: false,
            drawCircleMarker: false,
            drawRectangle: false,
            editMode: false,
            removalMode: false,
            cutPolygon: false,
            dragMode: false,
            rotateMode: false,
        });

        // A feature group to track user-drawn layers (so we can enforce "one at a time")
        const drawn = L.featureGroup().addTo(map);

        // 1) Limit Polyline to TWO points (finish draw on second click)
        map.on('pm:drawstart', ({ shape, workingLayer }) => {
            if (shape === 'Line') {
                workingLayer.on('pm:vertexadded', () => {
                    const pts = workingLayer.getLatLngs();
                    if (pts.length >= 2) {
                        // finish current line immediately after the 2nd point
                        if (map.pm?.Draw?.Line?._finishShape) {
                            map.pm.Draw.Line._finishShape(); // adds the finished layer to the map
                        } else {
                            // Fallback: stop draw mode; the second click will have created the layer already
                            map.pm.disableDraw();
                        }
                    }
                });
            }
});

        // 2) Allow only ONE Marker total (replace previous or disable the button)
        let currentMarker = null;

        map.on('pm:create', (e) => {
            const { layer, shape } = e;

            // Put new layers into our tracking group
            drawn.addLayer(layer);

            if (shape === 'Marker') {
                // If there's already a marker, remove it (keeping only the newest)
                if (currentMarker && map.hasLayer(currentMarker)) {
                    map.removeLayer(currentMarker);
                }
                currentMarker = layer;

                // Optionally disable the "drawMarker" button after one is placed
                if (map.pm?.Toolbar?.setButtonDisabled) {
                    map.pm.Toolbar.setButtonDisabled('drawMarker', true);
                }
            }

            if (shape === 'Line') {
                // Ensure any existing polylines are removed so only one line is kept
                drawn.eachLayer((l) => {
                    if (l !== layer && l instanceof L.Polyline && !(l instanceof L.Polygon)) {
                        map.removeLayer(l);
                    }
                });
            }

            // Update your hidden input (keep your existing logic)
            const geojson = layer.toGeoJSON();
            document.getElementById('GeoJsonCoordinates').value = JSON.stringify(geojson.geometry);
        });

        // Re-enable marker drawing if the marker gets removed
        map.on('pm:remove', (e) => {
            if (e.layer === currentMarker) {
                currentMarker = null;
                if (map.pm?.Toolbar?.setButtonDisabled) {
                    map.pm.Toolbar.setButtonDisabled('drawMarker', false);
                }
            }

            // Clear hidden field if everything was removed (keep your existing logic)
            document.getElementById('GeoJsonCoordinates').value = '';
        });

                        // ------------------------------------------------------------
                // LOCAL STORAGE: utkast-funksjon for kommentar og GeoJSON
                // ------------------------------------------------------------
                const formKey = "ObstacleReportForm";
                // Gjenopprett lagrede data n√•r siden lastes
                window.addEventListener("load", () => {
                  const notice = document.getElementById("restoreNotice");
                  const saved = localStorage.getItem(formKey);
                  notice.style.display = "none";
                  if (!saved) return;
                  const data = JSON.parse(saved);
                  const hasComment = data.comment && data.comment.trim().length > 0;
                  const hasGeo = data.geoJson && data.geoJson.trim().length > 0;
                  if (!(hasComment || hasGeo)) {
                    localStorage.removeItem(formKey);
                    return;
                  }
                  if (hasComment)
                    document.querySelector('[name="ObstacleComment"]').value = data.comment;
                  if (hasGeo) {
                    document.getElementById('GeoJsonCoordinates').value = data.geoJson;
                    notice.style.display = "block";
                // Tegn mark√∏r eller linje hvis geojson finnes
                try {
                  const geom = JSON.parse(data.geoJson);
                  if (geom.type === "Point" && geom.coordinates?.length === 2) {
                    const [lng, lat] = geom.coordinates;
                    const restoredMarker = L.marker([lat, lng]).addTo(map);
                    map.setView([lat, lng], 15);
                  }
                  else if (geom.type === "LineString" && Array.isArray(geom.coordinates)) {
                    // Konverter koordinatpar til Leaflet-format
                    const latlngs = geom.coordinates.map(([lng, lat]) => [lat, lng]);
                    const restoredLine = L.polyline(latlngs, { color: "orange", weight: 4 }).addTo(map);
                    map.fitBounds(restoredLine.getBounds());
                  }
                } catch (err) {
                  console.warn("Kunne ikke gjenopprette geometri:", err);
                }
                  }
                });
                // Lagre hvert 5. sekund (bare hvis det finnes data)
                setInterval(() => {
                  const comment = document.querySelector('[name="ObstacleComment"]').value || "";
                  const geo = document.getElementById('GeoJsonCoordinates').value || "";
                  const hasComment = comment.trim().length > 0;
                  const hasGeo = geo.trim().length > 0;
                  if (hasComment || hasGeo) {
                    localStorage.setItem(formKey, JSON.stringify({ comment, geoJson: geo }));
                  } else {
                    localStorage.removeItem(formKey);
                  }
                }, 5000);
                // Fjern ved innsending
                document.querySelector("form").addEventListener("submit", () => {
                  localStorage.removeItem(formKey);
                });
                // Manuell t√∏mming av utkast
                document.getElementById("clearDraftBtn").addEventListener("click", () => {
                  if (confirm("Er du sikker p√• at du vil slette utkastet?")) {
                    localStorage.removeItem(formKey);
                    document.querySelector('[name="ObstacleComment"]').value = "";
                    document.getElementById('GeoJsonCoordinates').value = "";
                    map.eachLayer(l => { if (l instanceof L.Marker) map.removeLayer(l); });
                    document.getElementById("restoreNotice").style.display = "none";
                  }
                });
    </script>
}
